---
title: 对象池模式
date: 2024-07-25 16:42:37
categories: DesignPatterns
tags: DesignPatterns
---

## 定义

放弃单独地分配和释放对象，从固定的池中重用对象，以提高性能和内存使用率

通俗易懂：在程序当中主要防止对象被频繁创建和销毁、减少GC、预加载等作用。

## 使用原因

* 内存碎片化原因：疯狂使用堆来使用与管理内存，则可能导致内存碎片化，浪费很多内存。
* 内存分配速度过慢：频繁创建对象则会导致内存分配速度过慢。

## 使用时机

* 需要频繁创建和销毁对象
* 对象大小相仿
* 在堆上进行对象内存分配十分缓慢或者导致内存碎片化
* 每个对象都封装了像数据库或者网络连接这样很昂贵又可以重用的资源

## 注意事项（TODO）

正常情况下依赖垃圾回收机制管理内存，但是使用对象池之后，处理内存的责任就落在自己的头上。

池可能在不需要的对象上浪费内存

对象池的大小需要根据需求设置。

同时只能激活固定数量的对象

### 设计决策

对象是否和池耦合？

- 耦合

  * 实现：在对象中添加一个标记来表示它是否被使用

  - 保证对象只能被对象池创建：最简单的方法是将对象设置为私有对象

- 未耦合

  - 保存多种类型的对象：这是最大的好处。通过解耦对象和对象池，你可以实现通用的、可重用的对象池类。
  - 必须在对象的外部追踪使用中状态。 做这点最简单的方式是创建分离的位字段

初始化对象问题

- 对象池内部重新初始化
  - 对象池完全封装管理对象：取决于对象需要的其他能力，你可以让它们完全处于池的内部。 这保证了其外部代码不会引用到已重用的对象。就不存在外部代码bug
  - 对象池与对象如何初始化相绑定：池中对象也许提供了不同的初始化函数。 如果对象池控制了初始化，它的接口需要支持所有的初始化函数，然后转发给对象。
- 外部代码初始化对象
  - 对象池接口更简单：对象池只需要简单地返回新对象引用
  - 外部代码需要处理创建新对象失败情况：安全起见，初始化之前检查该点

## 示例（TODO引用文章）

- [引用池]()
- [对象池]()

## 参考

[对象池模式 · Optimization Patterns · 游戏设计模式 (tkchu.me)](https://gpp.tkchu.me/object-pool.html)